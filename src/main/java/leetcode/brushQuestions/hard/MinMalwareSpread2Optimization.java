package leetcode.brushQuestions.hard;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * @author gusixue
 * @description 928. 尽量减少恶意软件的传播 II
 * @date 2024/4/17
 */
public class MinMalwareSpread2Optimization {

    /**
     * 反向并查集
     * 由于并查集只可以做合并，而无法拆分，因此反向考虑使用初始未感染的点做并查集
     * 接着遍历每个初始感染点（设为源点）判断会感染那些连通块，
     * 然后判断如果某个连通块能被超过 1 源点感染，则无法通过删除改源点导致连通块不感染；反之代表该源点能够导致此连通块均不被感染
     * 最后判断每个源点能够使多少个点（连通块的个数总和）不被感染，取最多的那个源点
     * 时间复杂度：O（n^2）
     */
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Arrays.sort(initial);
        int n = graph.length;

        // 源点对应下标

        Map<Integer, Integer> mapInitialIndex = new HashMap<>();
        for (int i = 0; i < initial.length; i++) {
            mapInitialIndex.put(initial[i], i);
        }
        // 所有未感染的节点
        List<Integer> listNotInitial = IntStream.range(0, n)
                .boxed()
                .filter(i -> !mapInitialIndex.containsKey(i))
                .collect(Collectors.toList());


        DSU dsu = new DSU(n);
        // 反向考虑使用初始未感染的点做并查集
        for (int i = 0; i < listNotInitial.size(); i++) {
            for (int j = 0; j < listNotInitial.size(); j++) {
                if (graph[listNotInitial.get(i)][listNotInitial.get(j)] > 0) {
                    dsu.union(listNotInitial.get(i), listNotInitial.get(j));
                }
            }
        }

        // 所有未感染节点所在的连通块根节点，能够被哪些源点感染
        Set<Integer>[] setDsuSpread = new HashSet[n];
        Arrays.setAll(setDsuSpread, i -> new HashSet<>());

        // 遍历每个初始感染点（设为源点）判断会感染那些连通块
        for (int initialVal : initial) {
            for (int i = 0; i < listNotInitial.size(); i++) {
                int notInit = listNotInitial.get(i);

                // initialVal 能够感染非源点的 i 则该连通块可以被它感染
                if (graph[notInit][initialVal] + graph[initialVal][notInit] > 0) {
                    int notInitAncestor = dsu.find(notInit);

                    setDsuSpread[notInitAncestor].add(initialVal);
                }
            }
        }
//        System.out.println(Arrays.toString(setDsuSpread));

        int[] initialSpreadCount = new int[initial.length];
        // 如果某个连通块能被超过 1 源点感染，则无法通过删除改源点导致连通块不感染；反之则可以
        // 判断每个源点能够使多少个点（连通块的个数总和）不被感染
        for (int i = 0; i < setDsuSpread.length; i++) {
            if (setDsuSpread[i].size() == 1) {
                int count = dsu.getCostByIndex(i);
                int initIndex = mapInitialIndex.get(setDsuSpread[i].iterator().next());

                initialSpreadCount[initIndex] += count;
            }
        }
//        System.out.println(Arrays.toString(initialSpreadCount));


        int res = initial[0];
        int notSpreadCount = -1;
        for (int i = 0; i < initialSpreadCount.length; i++) {
            if (initialSpreadCount[i] > notSpreadCount) {
                notSpreadCount = initialSpreadCount[i];
                res = initial[i];
            }
        }

        return res;
    }

    class DSU {
        // 代价为连通块中总个数
        private final int[] cost;
        private final int[] parent;
        private final int size;

        public DSU(int n) {
            this.size = n;

            parent = new int[n];
            cost = new int[n];
            for (int i = 0; i < n; ++i) {
                parent[i] = i;
                cost[i] = 1;
            }
        }

        public int find(int x) {
            if (parent[x] != x) {
                // 路径压缩
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }

        public void union(int u, int v) {
            int xAncestor = find(u);
            int yAncestor = find(v);
            if (parent[xAncestor] != yAncestor) {
                cost[yAncestor] += cost[xAncestor];
            }
            parent[xAncestor] = yAncestor;
        }

        public int getCostByIndex(int index) {
            return cost[index];
        }
    }
}
