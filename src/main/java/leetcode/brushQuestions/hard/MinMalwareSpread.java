package leetcode.brushQuestions.hard;

import java.util.*;

/**
 * @author gusixue
 * @description 924. 尽量减少恶意软件的传播
 * @date 2024/4/16
 */
public class MinMalwareSpread {

    /**
     * 可用并查集或连通分量优化为 n^2
     * 遍历 initial 删除每一个，判断最终节点数，
     * 判断时将已经感染的点放入 list，其中每个点在 graph 中判断能够感染到其他未感染的点，将其加入 list，同时 list 上限为所有点
     */
    public int minMalwareSpread(int[][] graph, int[] initial) {
        List<Integer> listVis = new ArrayList<>();
        boolean[] vis = new boolean[graph.length];
        int res = -1;
        int minCount = Integer.MAX_VALUE;

        for (int initialVal : initial) {
            initVis(listVis, vis, initial, initialVal);
//            System.out.println(listVis);

            int curCount = doMinMalwareSpread(listVis, vis, graph, initial.length - 1);
//            System.out.println(curCount + " : " + initialVal);

            if (curCount < minCount) {
                minCount = curCount;
                res = initialVal;

            } else if (curCount == minCount) {
                res = Math.min(initialVal, res);
            }

        }

        return res;
    }

    private int doMinMalwareSpread(List<Integer> listVis, boolean[] vis, int[][] graph, int count) {
        for (int i = 0; i < listVis.size(); i++) {
            int cur = listVis.get(i);

            for (int j = 0; j < graph.length; j++) {
                if (!vis[j] && graph[cur][j] + graph[j][cur] > 0) {
                    listVis.add(j);
                    vis[j] = true;
                    count++;
                }
            }

        }

        return count;
    }

    private void initVis(List<Integer> listVis, boolean[] vis, int[] initial, int initialVal) {
        listVis.clear();
        Arrays.fill(vis, false);

        for (int initialTemp : initial) {
            if (initialTemp != initialVal) {
                listVis.add(initialTemp);
                vis[initialTemp] = true;
            }
        }
    }
}
